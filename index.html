<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
        <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
        <meta name='mobile-web-app-capable' content='yes'>
        <meta name='apple-mobile-web-app-capable' content='yes'>
        <link rel='icon' type='image/png' sizes='32x32' href='favicon-32x32.png'>
        <link rel='icon' type='image/png' sizes='96x96' href='favicon-96x96.png'>
        <link rel='stylesheet' href='css/common.css'>
		<title>My first three.js app</title>
		<style>
			body { margin: 0;
                padding: 0;
             }
		</style>
	</head>
	<body>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.166.0/three.module.min.js" integrity="sha512-E5cKEv7OQBeKVN5/6o/u8tjtM5/noRHuWGW3/IJTSXlGOquJFZUvpj7NvduhYNVOFMOAVVEN7QSJ1T8d2xEqWw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
		
        <script type="module"> 
        import {WebXRButton} from './js/util/webxr-button.js';
      import {Scene} from './js/render/scenes/scene.js';
      import {Renderer, createWebGLContext} from './js/render/core/renderer.js';
      import {Node} from './js/render/core/node.js';
      import {Gltf2Node} from './js/render/nodes/gltf2.js';
      import {DropShadowNode} from './js/render/nodes/drop-shadow.js';
      import {vec3} from './js/render/math/gl-matrix.js';
      import {Ray} from './js/render/math/ray.js';
        import * as THREE from 'three';

        
      // XR globals.
      let xrButton = null;
      let xrRefSpace = null;
      let xrViewerSpace = null;
      let xrHitTestSource = null;
    // WebGL scene globals.
      let gl = null;
      let renderer = null;
      let scene = new Scene();
      scene.enableStats(false);

      let arObject = new Node();
      arObject.visible = false;
      scene.addNode(arObject);

      
      let sofa = new Gltf2Node({url: 'media/gltf/sofa_single.zip/scene.gltf'});
      //adding nodes to a particular object which would be eventually seen in the scene.
      arObject.addNode(sofa);
      let reticle = new Gltf2Node({url: 'media/gltf/reticle/reticle.gltf'});
      reticle.visible = false;
      scene.addNode(reticle);
// Having a really simple drop shadow underneath an object helps ground
      // it in the world without adding much complexity.
      let shadow = new DropShadowNode();
      vec3.set(shadow.scale, 0.15, 0.15, 0.15);
      
      arObject.addNode(shadow);
      const MAX_SOFAS = 1;
      let sofas = [];
      // Ensure the background is transparent for AR.
      scene.clear = false;

      function initXR() {
        xrButton = new WebXRButton({
          onRequestSession: onRequestSession,
          onEndSession: onEndSession,
          textEnterXRTitle: "START AR",
          textXRNotFoundTitle: "AR NOT FOUND",
          textExitXRTitle: "EXIT  AR",
        });
        document.querySelector('header').appendChild(xrButton.domElement);

        if (navigator.xr) {
          navigator.xr.isSessionSupported('immersive-ar')
                      .then((supported) => {
            xrButton.enabled = supported;
          });
        }
      }

      function onRequestSession() {
        return navigator.xr.requestSession('immersive-ar', {requiredFeatures: ['local', 'hit-test']})
                           .then((session) => {
          xrButton.setSession(session);
          onSessionStarted(session);
        });
      }
      
      function onSessionStarted(session) {
        session.addEventListener('end', onSessionEnded);
        session.addEventListener('select', onSelect);

        if (!gl) {
          gl = createWebGLContext({
            xrCompatible: true
          });

          renderer = new Renderer(gl);

          scene.setRenderer(renderer);
        }

        session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });
 // In this sample we want to cast a ray straight out from the viewer's
        // position and render a reticle where it intersects with a real world
        // surface. To do this we first get the viewer space, then create a
        // hitTestSource that tracks it.
        session.requestReferenceSpace('viewer').then((refSpace) => {
          xrViewerSpace = refSpace;
          session.requestHitTestSource({ space: xrViewerSpace }).then((hitTestSource) => {
            xrHitTestSource = hitTestSource;
          });
        });

        session.requestReferenceSpace('local').then((refSpace) => {
          xrRefSpace = refSpace;

          session.requestAnimationFrame(onXRFrame);
        });
      }

      
      function onEndSession(session) {
        xrHitTestSource.cancel();
        xrHitTestSource = null;
        session.end();
      }

      function onSessionEnded(event) {
        xrButton.setSession(null);
      }

      // Adds a new object to the scene at the
      // specified transform.
      function addARObjectAt(matrix) {
        let newSofa = arObject.clone();
        newSofa.visible = true;
        newSofa.matrix = matrix;
        scene.addNode(newSofa);

        Sofas.push(newSofa);

        // For performance reasons if we add too many objects start
        // removing the oldest ones to keep the scene complexity
        // from growing too much.
        if (flowers.length > MAX_FLOWERS) {
          let oldFlower = flowers.shift();
          scene.removeNode(oldFlower);
        }
      }

      let rayOrigin = vec3.create();
      let rayDirection = vec3.create();
      function onSelect(event) {
        if (reticle.visible) {
          // The reticle should already be positioned at the latest hit point, 
          // so we can just use it's matrix to save an unnecessary call to 
          // event.frame.getHitTestResults.
          addARObjectAt(reticle.matrix);
        }
      }
      
      // Called every time a XRSession requests that a new frame be drawn.
      function onXRFrame(t, frame) {
        let session = frame.session;
        let pose = frame.getViewerPose(xrRefSpace);

        reticle.visible = false;

        // If we have a hit test source, get its results for the frame
        // and use the pose to display a reticle in the scene.
        if (xrHitTestSource && pose) {
          let hitTestResults = frame.getHitTestResults(xrHitTestSource);
          if (hitTestResults.length > 0) {
            let pose = hitTestResults[0].getPose(xrRefSpace);
            reticle.visible = true;
            reticle.matrix = pose.transform.matrix;
          }
        }

        scene.startFrame();

        session.requestAnimationFrame(onXRFrame);

        scene.drawXRFrame(frame, pose);

        scene.endFrame();
      }

      // Start the XR application.
      initXR();
   
/*
//this button is taken from github page of three.js..it allows to create a webxr session.
import { ARButton } from 'https://unpkg.com/three@0.126.0/examples/jsm/webxr/ARButton.js';
//Container where we will have the 3d elements shown.
//const scene = new THREE.Scene();
//Camera defines the view or the field of view.
//perspective camera is seeing it from human eye point of view
//innerWidth is width of the container...same for height.
const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

//render to draw
//draw by appending it to canvas
const renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
renderer.setAnimationLoop( animate );
renderer.xr.enabled = true; // New!
document.body.appendChild( renderer.domElement );

const renderer = new THREE.WebGLRenderer({ antialias: true,alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setAnimationLoop(animate);
renderer.xr.enabled = true;

document.body.appendChild(renderer.domElement);

const geometry = new THREE.BoxGeometry( 1, 1, 1 );
const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
const cube = new THREE.Mesh( geometry, material );
cube.scale.set(0.5, 0.5, 0.5);
scene.add( cube );


camera.position.z = 2;
document.body.appendChild(ARButton.createButton(renderer));

// Handle window resize
window.addEventListener('resize', onWindowResize, false);

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}


function animate() {

	cube.rotation.x += 0.01;
	cube.rotation.y += 0.01;

	renderer.render( scene, camera );}
	cube.position.set(0, 0, -3);
    */

</script>
  </body>
</html>

